To get the lowest latency you need to turn off validation, FIX logging and message persistence.
Also make sure your system has enough memory and there is no other system load

Quickfix derivative with a large number of optimizations, much faster than the current release, especially for short messages. Includes sample application that measures latency over the loopback interface.

https://github.com/akorobka/quickfix/tree/quickerfix

Summary of the improvements

There are several things that have an adverse impact on the performance of the current reference implementation.

Most of them have to do with a large amount of redundant object copying, implicit type conversions and small block memory allocations. These changes try to reduce these as much as possible through a redesign of the field object, use of more efficient field containers (Boost, Google Sparsehash) with a custom pool allocator, and streamlined Tx/Rx pipelines.

Other changes are basically brute force optimizations using more efficient serialization/deserialization code, each contributing 0-20% to the total speedup.

Extensions

Each field type defines a nested Pack type that can be used for in-place field construction when adding a field to the message,

msg.setField( FIX::ClOrdID::Pack( "4" ) );

Double field constructors get an optional bool argument that specifies whether the value should be rounded.

msg.setField( FIX::DoubleField( field, value, precision, true ) );
msg.setField( FIX::Price( value, precision, true ) );
msg.setField( FIX::Price::Pack( value, precision, true ) );


------------------------------------------------------------------------------------------------------------------------
Are parallel calls to send/recv on the same socket valid?
1. Can we call send from one thread and recv from another on the same socket?
2. Can we call multiple sends parallely from different threads on the same socket?
https://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid

POSIX defines send/recv as atomic operations, so assuming you're talking about POSIX send/recv then yes, you can call them simultaneously from multiple threads and things will work.

This doesn't necessarily mean that they'll be executed in parallel -- in the case of multiple sends, the second will likely block until the first completes. You probably won't notice this much, as a send completes once its put its data into the socket buffer.

If you're using SOCK_STREAM sockets, trying to do things a parallel is less likely to be useful as send/recv might send or receive only part of a message, which means things could get split up.

Blocking send/recv on SOCK_STREAM sockets only block until they send or recv at least 1 byte, so the difference between blocking and non-blocking is not useful.